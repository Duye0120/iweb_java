# 封装继承多态的理解

● 假设有一家工厂，所生成的产品是电水壶，这种电水壶有这些主要特点：

> 1、由壶体和壶盖组成；
>
> 2、颜色是银白色的；
>
> 3、有一个开关可以控制启动烧水；
>
> 4、水烧开后会发出鸣叫声音报警。

按照面向对象的设计方法，我们把这个电水壶称为这个工厂的一"**类**"产品，简称为“**电水壶类**”，它具有同样的4个特点：

> 1、有两个成员**变量**：壶体和壶盖；
>
> 2、有一个成员**属性**：颜色，它的值等于银白色；
>
> 3、有一个成员**方法**：烧水（即按下开关就开始烧水）；
>
> 4、有一个成员**事件**：水已经烧开警报

**变量**用来存储类中的数据，**属性**用来表达或修改类的特征，**方法**用作执行类的功能，**事件**用来对外发送通知，**类**就是记录有一系列**变量**、**属性**、**方法**、**事件**成员的集合，所有具有这些特征成员的具体产品就叫做这个类的**对象，**这就是面向对象的程序设计理念来由**。**

用前面的例子来讲，“电水壶类”就是电水壶的产品设计规范，而具体的单个电水壶产品就是“电水壶类”的**对象**（有时也叫对象实例）。

这就是**类的封装**。

● 假设有一天，工厂想生产一种具有自动保温功能的电水壶，有两种方案：一是完全重新设计一个新的电水壶，二是在现有电水壶的基础上增加一个保温开关。很显然，第二种方式更经济实惠，工厂把这种新的电水壶称为**保温电水壶**，它增加了一个特点：

> 1、增加了一个开关： 保温，按下开关后可以对已经烧开的水进行自动保温。

按照前面的设计方法，由于新电水壶增加了一个成员，所以我们不能把它归纳到已有的“电水壶类”里面，但是我们可以建立一个新的类：“**保温电水壶类**”，它在“电水壶类”的基础上同样增加了一个新成员：

> 1、成员方法：保温（即按下开关就开始保温）

由于它基于“**电水壶类**”设计而来，因此我们把“**电水壶类**”称为“**保温电水壶类**”的**基础类**或**父类**，把“**保温电水壶类**”称为“**电水壶类**”的**继承类**或**子类**，它们之间是**继承**与**被继承**的关系，继承类自动具有基础类的所有特征成员。

由于**继承类**包括了**基础类**的所有成员，因此**继承类**也可以认为是**基础类**的一种。这个也很容易理解：我们可以把“**保温电水壶”**称为“**电水壶**”，但是不能把“**电水壶**”称为“**保温电水壶”**。假设客户要买1000个“电水壶”，现有产品数量不够时我们可以用“保温电水壶”来充数，但是客户要买1000个“保温电水壶”就绝对不能用“电水壶”来充数，是不是这个道理？

从程序设计的角度来讲，就是我可以把一个数据类型为“**保温电水壶类”**的对象赋值到一个数据类型为“**电水壶**”的变量，但是不允许把一个数据类型为“**电水壶**”的对象赋值到一个数据类型为“**保温电水壶类”**的变量。

需要注意的是：如果把一个数据类型为“**保温电水壶类”**的对象赋值到一个数据类型为“**电水壶**”的变量，那么这个变量里面实际存储的还是一个“**保温电水壶类”**对象，并不会因为变量的数据类型为“**电水壶**”存储进去的对象的数据类型就也为“**电水壶**”了。这个也很好理解：工厂用“**保温电水壶**”充作“**电水壶**”交付给了客户，不会因为这个充数行为就导致“**保温电水壶**”产品变成“**电水壶**”产品了。

这就是**类的继承**。

● 让我们继续假设，假设有一天工厂发现电茶壶的销路要比电水壶好，同样有两种方案：一是完全重新设计一个新的电茶壶，二是修改现有电水壶的烧水功能，将其改为烧茶。同样很显然，第二种方式更经济实惠。那么这种电茶壶的特点为：

> 1、修改了电水壶的烧水功能，使其改去烧茶。

同样，我们需要定义一个名为“**电茶壶类**”的类，然后定义一个同样名为“**烧水**”的方法，该方法覆盖了“**电水壶类**”中的原有名为“**烧水**”的方法，然后将“**电水壶类**”中的“**烧水**”方法标记为**[虚拟方法](http://www.xueshanlinghu.com/wp-content/themes/begin201117/go.php?url=aHR0cDovL2RvYy52b2xkcC5jb20vZ3JhbW1hci5odG0jdmlydHVhbF9tZXRob2Q=)**（虚拟方法仅是一个标记，用作标记“**烧水**”方法可以被继承类覆盖），这样以后调用“**电茶壶类**”类的“**烧水**”方法时，就会改去烧茶，而不会去烧水。

需要注意的是：如果把一个数据类型为“**电茶壶类”**的对象赋值到一个数据类型为“**电水壶**”的变量，据前所述，这个变量里面实际存放的还是一个“**电茶壶类”**的对象，因此如果调用该变量的“**烧水**”方法，实际上调用的还是“**电茶壶类”**的烧茶功能。

这就是**类的多态**。





# 总结：面试要点

## 面向对象基础：

1. 类
2. 对象
3. 属性
4. 方法
5. 参数传递
6. 构造函数
7. 构造函数重载
8. this关键字
9. 成员变量、局部变量
10. 方法重载

## 面型对象设计

1. 封装： 定义、使用方式、set、get
2. 继承：定义、特征、方法重写 VS 方法重载的区别、super
3. 多态：编译多态和运行时多态
4. 抽象：抽象类、抽象方法、抽象类的特征
5. 设计模式： 设计模式的7大原则（4个就够了）、模板方法
6. 面向对象设计的目的： 解耦、代码复用、业务分离

# 编码要求

面向对象的所有的特征。都能通过代码去熟练的演示出来。

# 练习

群主发普通红包。某群有多名成员，群主给成员发普通红包。普通红包的规则： 

1. 群主的一笔金额，从群主余额中扣除，平均分成n等份，让成员领取。

2. 成员领取红包后，保存到成员余额中。

请根据描述，完成案例中所有类的定义以及指定类之间的继承关系，并完成发红包的操作。

![image-20210422141538597](https://mx-assets.oss-cn-beijing.aliyuncs.com/MySQL/image-20210422141538597.png)

**代码实现**

提示：跟微信红包【需要输入几个值】

群主发红包，就是把一个整数的金额，分成若干等份。

1.获取群主余额,是否够发红包. 不能则返回null,并提示. 能则继续.

2.修改群主余额，生成红包.  int[] sendMoney(int money,int count)  

​	2.1.如果能整除，那么就平均分。---->取法，同双色球

​	2.2.如果不能整除，那么就把余数分给最后一份。 

3.拆分红包.  int  getMoney(int[] arrs)

4.群员打开红包,就是从数组中,随机取出一份,保存到自己的余额中